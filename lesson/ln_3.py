# def calc1(a, b):
#     return a+b


# def math(op, x, y):
#     print(op(x, y))


# math(lambda a, b: a+b, 5, 45)

# в списке хронятся числа. Нужно выбрать только четные числа и составить список пар(число, квадрат числа)
# a = 1
# my_list= [1,2,3,5,8,15,23,38]
# res = list()
# for item in my_list:
#     if item %2 ==0:
#         res.append((item,item**2))
# print(res)


# def select(f, col):
#     return [f(x) for x in col]


# def where(f, col):
#     return [x for x in col if f(x)]


# my_list = [1, 2, 3, 5, 8, 15, 23, 38]
# res = select(int, my_list)
# print(res)
# res = where(lambda x: x % 2 == 0, res)
# print(res)
# res = select(lambda x: (x, x**2), res)
# print(res)


# list_1 = [i for i in range(1,20)]
# print (list_1)
# list_1 = list(map(lambda x: x+10,list_1))
# print(list_1)

# data = '15 156 96 3 5 8 52 5'
# print(data)
# # data = data.split(" ")

# data = list(map(int,data.split() )) # map включает в себя все обьекты
# print(data)


# data = [15, 65 , 9 , 36, 175]
# print(data)
# data = list(filter(lambda x: x%10 == 5, data))
# print(data)

# функция zip пробегает по минимальному входящему набору, собирает кортеж 

# users = ['users1', 'users2', 'users3', 'users4', 'users5']
# ids = [4, 5, 6, 7, 2]
# data = list(zip(users, ids))
# print(data)

# функция enumerate() применяется к итерируему объекту и возвращает новый итератор с кортежами из индекса входного элемента
# функция enumerate() позволяет пронумеровывать набор данных

# users = ['user1', 'user2', 'user3']
# data = list(enumerate(users))
# print(data)


# файлы 
# файлы в тектовом формате используются для :
# хранение данных
# предача данных в клинт- серверных проектах
# хранение конфигов
# логирование действий

# что нужно для работы с файлами:
# завести переменную которая будет связана с тектовым файлом
# указать путьк файлу
# указать путь в каком режиме мы будем работаь с файлом

# варианты режима(мод):

# a- открытый для добавления данных.
# позволяет дописывать что то в имеющиеся файлы
# если вы попробуете дописать что то в несуществующий файо
# ир файл будет создан и в него начнется запись

# r- открытие для чтения данных:

# позволяет читать данные из файла.
# если вы попробуете считать данные из файла, 
# которого не существует, программа выдаст ошибку

# w- открытие для записи данных

# позводяет записывать данные и создавать файл, если его не существует 

# colors = ['red', 'green', 'blue']
# data= open('file.txt', 'a') # режим в котором будем работать
# data.writelines(colors)# разделителей не будет
# data.close()# закрываем файл

# with open('file.txt', 'w') as data:
#     data.write('line 1\n')
#     data.write('line_2\n')

# path = 'file.txt'
# data = open('file.txt', 'r')
# for line in data:
#     print(line)
# data.close()

# модуль OS

# модуль os представляет с собой множество функции для работы с операционной системой, причем их поведение, как правило
# не зависит от os , поэтому программы остаются переносными

# для того что бы начать работать с данным модулем необходимо его импортировать в свою программу 

# import os

# базовые функции модуля
# os.chdir(path) смена текущий директории
# os.chdir() текущая дериктория 

# os.path является вложенным модулем в модуль os  и реализует  некоторые полезные функции для работы с путями такие как
# os.path.basename(path) базовое имя пути

# вводить полный путь, выводят имя пути(файла)
# os.path.abspath(path) возвращает  нормализованный обсалютный путь  (вводить имя файла, выводит полный путь)


# модуль shutil содержит набор функции высокого уровня для обработки файлов, групп файлов, и папок. В частности доступные здесь
# функции позволяют копирывать перемещать и удалять файлы и папки. часто используются вместе с модулем OS 

# import shutil

# базовые функции

# shutil.copyfile(src,dst) копирует содержимое файла, но не методанные файла src в файл dst
# shutil.copy(src,dst) копирует содержимое файла src в файл или папку dst
# shutil.rmtree(path) удаляет текущую директорию и все поддиректории; path должен указывать на директорию а не на символическую ссылку